首先在最初点出对于时间/空间复杂度存在的一个问题，**事后统计法**。

1. 测试结果非常依赖测试环境

>比如说在 Mac 上跑的结果和 Windows 上跑的结果可能会有很大差异，甚至同一台机器上不同时间段跑的结果也会有差异。

这点可以通过多次测试取平均值来缓解，但仍然无法完全消除环境差异带来的影响。

2. 测试结果受数据规模的影响很大

>比如对于 TopK 的排序问题，对于数据量比较小的时候，golang 实现快排的性能可能会更好一些，但是数据量较大之后，堆的优势就会逐渐显现。

这里总结一下：
>如果数据是流式或非常大，用堆；如果数据能一次性放内存并且只做一次 Top-K，用 Quickselect 会更快。

希望看到这里的你不再是一个初学者，而是对数据结构与算法有了更深入理解的学习者。那么我们就不在拿大学里面的通识性课程来讲解数据结构与算法，而是从更高的层次来分析数据结构与算法的学习方法论。

**这里分享一下我对复杂度分析的思考吧：**

算法远不能停滞在理论层面，对于时空复杂度的分析，也是更好的帮助我们分析问题。我们更多 care 的是，通过使用相关的算法给我们解决一个又一个工程上的相关问题，提高我们程序执行的效率。

对于时间复杂度，我们要去看算法具体是怎么样执行的，在实现的过程中嵌套了几层循环，调用了什么方法。

对于空间复杂度，我们要去注意，这里算法的具体执行流程不是那么重要了，也不需要像时间复杂度分析过程那么关注整体的流程了，也是说，整体上的代码创建了什么样的结构，比如链表、数组等等，同时也需要排除原本自带的结构，进行综合分析。

**总结起来：**

时间复杂度：是算法的执行效率，通常我们要去依靠循环次数和嵌套次数
空间复杂度：是算法的内存消耗，通常我们要去依靠算法开辟的空间和数据结构
