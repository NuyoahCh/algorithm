摘抄一段是否经典的内容：
>数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。

作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。

2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。

3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList > array。

接下来，再补充一点静态数组和动态数组相关知识点：

综上，静态数组的增删查改操作的时间复杂度是：

>对于静态数组

增：
在末尾追加元素：O(1)。
在中间（非末尾）插入元素：O(N)。

删：
删除末尾元素：O(1)。
删除中间（非末尾）元素：O(N)。
查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)。
改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)。

所以对于静态数组而言，增删操作的时间复杂度较高，尤其是在中间位置进行插入或删除操作时，需要移动大量元素，导致时间复杂度为 O(N)。而查找和修改操作则非常高效，时间复杂度为 O(1)。

----------------------------

>对于动态数组

首先，你不要以为动态数组可以解决静态数组在中间增删元素效率差的问题，不可能解决的。数组随机访问的超能力源于数组连续的内存空间，而连续的内存空间就不可避免地面对数据搬移和扩缩容的问题。

这本身就是数组这样连续存储空间自带的缺陷，动态数组无法改变这一点。

动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已。


---


总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。


---

这里再补充一下环形数组的实现原理吧：

环形数组技巧利用求模（余数）运算，将普通数组变成逻辑上的环形数组，可以让我们用 O(1) 的时间在数组头部增删元素。

数组可能是环形的么？不可能。数组就是一块线性连续的内存空间，怎么可能有环的概念？

但是，我们可以在「逻辑上」把数组变成环形的，比如下面这段代码：

```go
import "fmt"

func main() {
    // 长度为 5 的数组
    arr := []int{1, 2, 3, 4, 5}
    i := 0
    // 模拟环形数组，这个循环永远不会结束
    for i < len(arr) {
        fmt.Println(arr[i])
        i = (i + 1) % len(arr)
    }
}
```

这段代码的关键在于求模运算 %，也就是求余数。当 i 到达数组末尾元素时，i + 1 和 arr.length 取余数又会变成 0，即会回到数组头部，这样就在逻辑上形成了一个环形数组，永远遍历不完。

>理论上，你可以随意设计区间的开闭，但一般设计为左闭右开区间是最方便处理的。

推荐对于设计区间的开始和结束，没有特殊情况都按照我上述去说明的方式去设计，能让你少犯错误。

再举一个例子，比如二分查找的时候，上述的左闭右开的方式进行设计，能让你降低很多心智成本。

---

最后留一个小问题：

>为什么编程语言的标准库中提供的动态数组容器底层并没有用环形数组技巧？

如果用环形数组，增删查改的的所有操作都会涉及 % 求模运算，这个操作是比较消耗性能的。尤其像数组的 get 方法，调用频率会非常非常高，如果每次调用都多一步 % 运算，加起来的性能损耗远大于环形数组带来的收益，因为数组很少在头部增删元素。如果你非要在头部增删，应该使用更合适的其他数据结构。


所以一般只会在双端队列这种场景下使用环形数组，标准的动态数组并没有使用这个技巧。不是不能用，而是算总账不划算。